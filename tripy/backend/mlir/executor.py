import numpy as np
import ctypes

from tripy.backend.mlir.mlir import mlir_wrapper, void_ptr
from tripy.logging import G_LOGGER
from tripy.flat_ir import FlatIR
from tripy.util import log_time


class FlatIRExecutor:
    """
    Represents the compiler for FlatIR which converts FlatIR into a StableHLO representation and compiles it into an executable using mlir-tensorrt compiler.
    """

    def __init__(self, flat_ir: FlatIR) -> None:
        self.compiler = mlir_wrapper()
        self.flat_ir = flat_ir

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            info = (exc_type, exc_value, traceback)
            G_LOGGER.exception("Execption occured in FlatIRExecutor", exc_info=info)
        return False

    @log_time
    def execute(self, executable, execargs) -> np.ndarray:
        """
        Executes the compiled MLIR program and returns the output of the computation as a numpy array.
        Execute function assumes that the inputs to the program are folded into the flatIR/MLIR computation as of 10/23/23.
        Args:
            executable: MLIR executable generated by FlatIRCompiler
        Returns:
            numpy array for the output tensor.
        """
        arrays = (ctypes.c_void_p * len(self.flat_ir.outputs))()
        # Create an empty numpy array representing the output tensor of flatIR.
        outputs = [np.zeros(o.shape, dtype=np.float32) for o in self.flat_ir.outputs]
        for i in range(len(self.flat_ir.outputs)):
            arrays[i] = outputs[i].ctypes.data_as(void_ptr)

        # Todo: arrays should be folded into execargs
        self.compiler.execute(executable, arrays, execargs)
        return outputs
