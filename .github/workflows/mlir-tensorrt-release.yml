name: MLIR-TensorRT Release Wheel and Tarball

on:
  workflow_call:
    inputs:
      build-matrix:
        description: 'Build matrix to utilize'
        default: ""
        type: string
      arch:
        description: 'Architecture, valid values are "x86_64" or "aarch64"'
        default: "x86_64"
        type: string
      github_runner:
        description: 'Runner, valid values are "linux-amd64-gpu-h100-latest-1" or "linux-arm64-gpu-l4-latest-1"'
        default: "linux-amd64-gpu-h100-latest-1"
        type: string

defaults:
  run:
    shell: bash

jobs:
  mlir-tensorrt-wheel-build:
    name: ${{ inputs.arch }}-cu${{ matrix.cuda }}-trt${{ matrix.trt }}-wheel-build
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJSON(inputs.build-matrix) }}
    env:
      # eg. 10.12 or 10.13
      DOWNLOAD_TENSORRT_VERSION: ${{ matrix.trt }}
      LATEST_CUDA_VERSION: ${{ matrix.latest_cuda }}
      LATEST_TENSORRT_VERSION: ${{ matrix.latest_trt }}
      ARCH: ${{ inputs.arch }}
      CCACHE_DIR: ${{ github.workspace }}/mlir-tensorrt/ccache
      CPM_SOURCE_CACHE: ${{ github.workspace }}/mlir-tensorrt/.cache.cpm
      CMAKE_PRESET: distribution-wheels
      CCACHE_KEY: mlir-tensorrt-ccache-v1-${{ inputs.arch }}-distribution-wheels
      # if exact cache key is not matched, fallback to the restore key to restore the cache
      CCACHE_RESTORE_KEY: mlir-tensorrt-ccache-v1-${{ inputs.arch }}-
      CPM_KEY: mlir-tensorrt-cpm-v1
      CPM_RESTORE_KEY: mlir-tensorrt-cpm-v1
      WHEELS_DIR: ${{ github.workspace }}/mlir-tensorrt/.wheels/
    runs-on: ${{ inputs.github_runner }}
    timeout-minutes: 120
    container:
      image: ${{ matrix.docker_image }}
      options: >-
        --gpus all
        --shm-size=1g
    steps:
      # Checkout the repository
      - name: Checkout TensorRT-Incubator
        uses: actions/checkout@v5
        with:
          fetch-depth: 5

      # Create cache folders
      - name: Create Cache Folders
        run: |
          set -euo pipefail
          set -x
          mkdir -p ${{ env.CCACHE_DIR }}
          mkdir -p ${{ env.CPM_SOURCE_CACHE }}

      # Restore cache, if exists.
      - name: Restore CCache
        id: restore-ccache
        uses: actions/cache/restore@v4
        with:
          key: ${{ env.CCACHE_KEY }}
          restore-keys: |
            ${{ env.CCACHE_RESTORE_KEY }}
          path: |
            ${{ env.CCACHE_DIR }}

      - name: Restore CPM cache
        id: restore-cpm
        uses: actions/cache/restore@v4
        with:
          key: ${{ env.CPM_KEY }}
          enableCrossOsArchive: true
          restore-keys: |
            ${{ env.CPM_RESTORE_KEY }}
          # exclude only works for the relative path pattern
          # restore must use the exactly same path defined in the save step, cannot ignore the exclude path
          path: |
            mlir-tensorrt/.cache.cpm/*
            !mlir-tensorrt/.cache.cpm/tensorrt
            !mlir-tensorrt/.cache.cpm/tensorrt/**

      # Build wheels
      - name: Build Wheels With CUDA:${{ matrix.cuda }} + TensorRT:${{ matrix.trt }}
        env:
          ENABLE_ASAN: "OFF"
        run: |
          set -euo pipefail
          set -x
          cd mlir-tensorrt
          export MTRT_TENSORRT_VERSION=${{ matrix.trt }}
          # TODO: remove this, once patch is in our rockylinux prebuilt image
          dnf install -yq patch
          # mlir-tensorrt-tools is not cuda, trt dependent, so we only build it once
          # mlir-tensorrt-compiler, mlir-tensorrt-runtime is built per cuda, trt version
          if [[ "${{ matrix.cuda }}" == "${{ env.LATEST_CUDA_VERSION }}" && "${{ matrix.trt }}" == "${{env.LATEST_TENSORRT_VERSION }}" ]]; then
            ./build_tools/scripts/cicd-build-wheels.sh
          else
            PACKAGES="mlir_tensorrt_compiler mlir_tensorrt_runtime" \
            ./build_tools/scripts/cicd-build-wheels.sh
          fi

      # Save ccache when cache is not hit or cache was a fallback(cache-matched is not the same as the cache key)
      - name: Save CCache
        uses: actions/cache/save@v4
        if: ${{ steps.restore-ccache.outputs.cache-hit != 'true' || steps.restore-ccache.outputs['cache-matched-key'] != env.CCACHE_KEY }}
        with:
          key: ${{ env.CCACHE_KEY }}
          path: |
            ${{ env.CCACHE_DIR }}

      # Save cpm cache
      - name: Save CPM Cache
        # cpm cache is shared across x86_64 and aarch64, we let only x86_64 to save cpm cache when in cache miss case
        # this is to avoid both x86_64 and aarch64 to save cpm cache when in cache miss case
        if: ${{ inputs.arch == 'x86_64' &&
              (
                steps.restore-cpm.outputs.cache-hit != 'true' ||
                steps.restore-cpm.outputs['cache-matched-key'] != env.CPM_KEY
              )
            }}
        uses: actions/cache/save@v4
        with:
          key: ${{ env.CPM_KEY }}
          enableCrossOsArchive: true
          # exclude only works for the relative path pattern
          path: |
            mlir-tensorrt/.cache.cpm/*
            !mlir-tensorrt/.cache.cpm/tensorrt
            !mlir-tensorrt/.cache.cpm/tensorrt/**

      # Upload wheels to GitHub Actions artifact
      - name: Upload Wheels
        uses: actions/upload-artifact@v4
        with:
          name: release-wheels-${{ inputs.arch }}-cu${{ matrix.cuda }}-trt${{ matrix.trt }}
          path: ${{ env.WHEELS_DIR }}
          if-no-files-found: error

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref_name }}-mlir-tensorrt-release-${{ inputs.arch }}
  cancel-in-progress: true