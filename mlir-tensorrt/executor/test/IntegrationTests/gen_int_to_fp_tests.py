#!/usr/bin/env python3
"""
Generate MLIR functions exercising executor.uitofp and
executor.sitofp for a menu of test cases
in multiple element types:
- target types: f64, f32, f16, bf16, f8E4M3FN
- source types: i8, i16, i32, i64, i4

Test sitofp for these input cases:
 - 0.0, 1.0, -1.0, int_min, int_max

Test uitofp for these input cases:
 - 0.0, 1.0, int_max
"""

FP_INFO = {
    "f64": {
        "inf": "0x7ff0000000000000",
        "-inf": "0xfff0000000000000",
        "max": 1.7976931348623157e308,  # 1.7976931348623157e+308
        "eps": "0x0000000000000001",  # 5e-324
        "min": -1.7976931348623157e308,  # -1.7976931348623157e+308
    },
    "f32": {
        "inf": "0x7f800000",
        "-inf": "0xff800000",
        "max": 3.4028235e38,  # 3.4028235e+38
        "eps": "0x00000001",  # 1.4e-45
        "min": -3.4028235e38,  # -3.4028235e+38
    },
    "bf16": {
        "inf": "0x7f80",
        "-inf": "0xff80",
        "max": 3.389531e38,  # 3.389531e+38
        "eps": "0x0001",  # 9.183549615799121e-41
        "min": -3.389531e38,  # -3.389531e+38
    },
    "f16": {
        "inf": "0x7c00",
        "-inf": "0xfc00",
        "max": 65504.0,  # 65504
        "eps": "0x0001",  # 5.96e-8
        "min": -65504.0,  # -65504
    },
    "f8E4M3FN": {
        "inf": "448.",
        "-inf": "-448.",
        "max": 448.0,  # 448
        "eps": "0x01",  # 0.0625
        "min": -448.0,  # -448
    },
}

SIGNED_INT_MAP = {
    "i8": {"min": -128, "max": 127},
    "i16": {"min": -32768, "max": 32767},
    "i32": {"min": -2147483648, "max": 2147483647},
    "i64": {"min": -9223372036854775808, "max": 9223372036854775807},
    "i4": {"min": -8, "max": 7},
}
UNSIGNED_INT_MAP = {
    "i8": {"max": 255},
    "i16": {"max": 65535},
    "i32": {"max": 4294967295},
    "i64": {"max": 18446744073709551615},
    "i4": {"max": 15},
}


FP_TYPES = ["f64", "f32", "f16", "bf16", "f8E4M3FN"]
INT_TYPES = ["i8", "i16", "i32", "i64", "i4"]


def emit_sitofp(fp_tp: str, int_tp: str):
    print(
        f"  func.func private @sitofp_{int_tp}_{fp_tp}(%x: {int_tp}) -> {fp_tp} attributes {{no_inline}} {{"
    )
    print(f"    %1 = executor.sitofp %x : {int_tp} to {fp_tp}")
    print(f"    return %1 : {fp_tp}")
    print("  }")
    print("")


def emit_uitofp(fp_tp: str, int_tp: str):
    print(
        f"  func.func private @uitofp_{int_tp}_{fp_tp}(%x: {int_tp}) -> {fp_tp} attributes {{no_inline}} {{"
    )
    print(f"    %1 = executor.uitofp %x : {int_tp} to {fp_tp}")
    print(f"    return %1 : {fp_tp}")
    print("  }")
    print("")


# ---------------------------------------------------------------------------
def emit_module():
    print(
        "//===----------------------------------------------------------------------===//"
    )
    print("//  Auto-generated tests for arith.remf")
    print("//  Generated by gen_int_to_fp_tests.py")
    print(
        "//===----------------------------------------------------------------------===//\n"
    )
    print("module {")
    # Loop over element types then tests to group functions by type.
    for fp_tp in FP_TYPES:
        for int_tp in INT_TYPES:
            emit_sitofp(fp_tp, int_tp)
            emit_uitofp(fp_tp, int_tp)

    test_case_names = []
    for fp_tp in FP_TYPES:

        def remap_expected(expected):
            if expected > FP_INFO[fp_tp]["max"]:
                return FP_INFO[fp_tp]["inf"]
            elif expected < FP_INFO[fp_tp]["min"]:
                return FP_INFO[fp_tp]["-inf"]
            return expected

        for int_tp in INT_TYPES:
            sitofp_cases = [
                (0, 0.0),
                (-1, -1.0),
                (SIGNED_INT_MAP[int_tp]["max"], float(SIGNED_INT_MAP[int_tp]["max"])),
                (SIGNED_INT_MAP[int_tp]["min"], float(SIGNED_INT_MAP[int_tp]["min"])),
            ]

            for idx, (case, expected) in enumerate(sitofp_cases):
                func_name = f"@test_sitofp_{int_tp}_{fp_tp}_{idx}"
                test_case_names.append(func_name)

                expected = remap_expected(expected)

                print(f"  func.func {func_name}() attributes {{no_inline}} {{")
                print(f'    executor.print "test {func_name}"()')
                print(f"    %x = executor.constant {case} : {int_tp}")
                print(f"    %expected = executor.constant {expected} : {fp_tp}")
                print(
                    f"    %1 = call @sitofp_{int_tp}_{fp_tp}(%x) : ({int_tp}) -> ({fp_tp})"
                )
                val_str = f"%1"
                expected_str = f"%expected"
                print_type = fp_tp
                if fp_tp in set(["f8E4M3FN", "bf16", "f16"]):
                    val_str = f"%2"
                    expected_str = f"%3"
                    print_type = "f32"
                    print(f"    %2 = executor.extf %1 : {fp_tp} to f32")
                    print(f"    %3 = executor.extf %expected : {fp_tp} to f32")
                print(
                    f'    executor.print "got %f, expected %f" ({val_str}, {expected_str} : {print_type}, {print_type})'
                )
                print(f"    %eq = executor.fcmp <oeq> %1, %expected : {fp_tp}")
                print(f'    executor.assert %eq, "sitofp {fp_tp} {int_tp} failed"')
                print("    return")
                print("  }\n")

            uitofp_cases = [
                (0, 0.0),
                (1, 1.0),
                (
                    UNSIGNED_INT_MAP[int_tp]["max"],
                    remap_expected(float(UNSIGNED_INT_MAP[int_tp]["max"])),
                ),
            ]

            for idx, (case, expected) in enumerate(uitofp_cases):
                func_name = f"@test_uitofp_{int_tp}_{fp_tp}_{idx}"
                test_case_names.append(func_name)

                print(f"  func.func {func_name}() attributes {{no_inline}} {{")
                print(f'    executor.print "test {func_name}"()')
                print(f"    %x = executor.constant {case} : {int_tp}")
                print(f"    %expected = executor.constant {expected} : {fp_tp}")
                print(
                    f"    %1 = call @uitofp_{int_tp}_{fp_tp}(%x) : ({int_tp}) -> ({fp_tp})"
                )
                val_str = f"%1"
                expected_str = f"%expected"
                print_type = fp_tp
                if fp_tp in set(["f8E4M3FN", "bf16", "f16"]):
                    val_str = f"%2"
                    expected_str = f"%3"
                    print_type = "f32"
                    print(f"    %2 = executor.extf %1 : {fp_tp} to f32")
                    print(f"    %3 = executor.extf %expected : {fp_tp} to f32")
                print(
                    f'    executor.print "got %f, expected %f" ({val_str}, {expected_str} : {print_type}, {print_type})'
                )
                print(f"    %eq = executor.fcmp <oeq> %1, %expected : {fp_tp}")
                print(f'    executor.assert %eq, "uitofp {fp_tp} {int_tp} failed"')
                print("    return")
                print("  }\n")

    print("  // ---- Entrypoint ----")
    print("  func.func @main() -> i32{")
    for name in test_case_names:
        print(f"    call {name}() : () -> ()")
    print("    %c0 = executor.constant 0 : i32")
    print("    return %c0 : i32")
    print("  }")
    print("}")


# ---------------------------------------------------------------------------
if __name__ == "__main__":
    emit_module()
