# RUN: %pick-one-gpu %mlir-trt-jax-py %s
# UNSUPPORTED: tensorrt-version-eq-9

import pytest

"""
This test constructs a simple test of the "greedy" style language model decoder
loop seen in many models (e.g. Flax GPT decoding models). The loop-carried state
is a structure that carries the current iteration index, the accumulated
sequences, the next token to process, and a per-batch indicator for whether the
sentance is finished. We generate "logits" at each iteration of the body so that
since greedy-style decoders use an `argmax` operation on the logits. We craft
the logits so that the largest value is always in the position equal to the
current iteration. This ensures that the generated sequence will be equal to
`[...context..., CONTEXT_LENGTH, CONTEXT_LENGTH+1, ..., MAX_LENGTH-1]`.
"""

import flax.struct
import jax.numpy as jnp
import numpy as np
from jax import jit, lax

PAD_TOKEN_ID: int = 0
NUM_TOKENS: int = 20
EOS_TOKEN_ID: int = NUM_TOKENS - 1
MAX_LENGTH: int = NUM_TOKENS
BATCH_SIZE: int = 1


@flax.struct.dataclass
class GreedyState:
    # A scalar indicating the current index in the sequences array.
    cur_len: jnp.ndarray
    # The accumlated sequences being generated by the loop.
    sequences: jnp.ndarray  # (batch_size, max_seq_length)
    # The current token or context. For the first iteration, `?` is the length
    # of the context. For subsequent iterations, `?` is 1.
    running_token: jnp.ndarray  # (batch_size, ?)
    # A boolean indicating whether each sentance in the batch is done.
    is_sent_finished: jnp.ndarray  # (batch_size,)


@jit
def greedy_decoder_loop(input_ids):
    batch_size, context_len = input_ids.shape

    eos_token_id = jnp.array(EOS_TOKEN_ID, dtype=jnp.int32)
    pad_token_id = jnp.array(PAD_TOKEN_ID, dtype=jnp.int32)
    context_len = jnp.array(context_len)

    # Initialize 'sequences' to max length filled with padding value.
    sequences = jnp.full((batch_size, MAX_LENGTH), pad_token_id, dtype=jnp.int32)
    # Insert the context into the start of 'sequences'.
    sequences = lax.dynamic_update_slice(sequences, input_ids, (0, 0))

    # Initialize completion indicators to all false.
    is_sent_finished = jnp.zeros((batch_size,), dtype=jnp.bool_)

    # initialize state
    state = GreedyState(
        cur_len=context_len,
        sequences=sequences,
        running_token=input_ids,
        is_sent_finished=is_sent_finished,
    )

    def greedy_search_cond_fn(state):
        """We terminate the while loop if all senantances are done early
        or if we iterated the max number of times.
        """
        has_reached_max_length = state.cur_len == MAX_LENGTH
        all_sequence_finished = jnp.all(state.is_sent_finished)
        finish_generation = jnp.logical_or(
            has_reached_max_length, all_sequence_finished
        )
        return ~finish_generation

    def greedy_search_body_fn(state):
        """For this simple test, we generate "logits" at each time step
        so that the next token can be chosen from an `argmax` operation on the
        logits. We craft the logits so that the largest value is always in the
        position equal to the current iteration. This ensures that the generated
        sequence will be equal to `[0, 1, 2, ..., MAX_LENGTH-1]`.
        """
        logits = jnp.full((state.running_token.shape[0], NUM_TOKENS), 0.1)
        logits = lax.dynamic_update_slice(
            logits, jnp.full((1, 1), 1.0), (0, state.cur_len)
        )
        next_token = jnp.argmax(logits, axis=-1)

        # Use `is_sent_finished` as a mask to control whether we output pad token
        # or next token.
        next_token = (
            next_token * ~state.is_sent_finished + pad_token_id * state.is_sent_finished
        )
        next_is_sent_finished = state.is_sent_finished | (next_token == eos_token_id)

        # Update sequences with the chosen token.
        next_token = next_token[:, None]
        next_sequences = lax.dynamic_update_slice(
            state.sequences, next_token, (0, state.cur_len)
        )

        return GreedyState(
            cur_len=state.cur_len + 1,
            sequences=next_sequences,
            running_token=next_token,
            is_sent_finished=next_is_sent_finished,
        )

    if input_ids.shape[1] > 1:
        state = greedy_search_body_fn(state)

    return lax.while_loop(greedy_search_cond_fn, greedy_search_body_fn, state)


@pytest.mark.unsupported_trt_version(major=9)
def test_greedy_decoder_loop():
    """Test greedy decoder loop with context and sequence generation."""
    input_ids = jnp.arange(0, 6, dtype=jnp.int32).reshape((1, 6))
    result = greedy_decoder_loop(input_ids).sequences

    np.testing.assert_array_equal(
        np.asarray(result),
        np.arange(0, MAX_LENGTH, dtype=np.int32).reshape(1, MAX_LENGTH),
    )


if __name__ == "__main__":
    pytest.main(["-v", __file__])
